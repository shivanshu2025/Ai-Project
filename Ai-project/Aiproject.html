<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled 3D Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-element { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; z-index: 0; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #00ffcc; z-index: 2;
            pointer-events: none; text-shadow: 0 0 10px #00ffcc;
        }
        .instruction { font-size: 14px; margin-bottom: 5px; color: rgba(255,255,255,0.7); }
        .status { font-weight: bold; font-size: 18px; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; z-index: 10;
        }
    </style>
</head>
<body>

    <div id="loading">Loading AI Vision...</div>

    <div id="ui">
        <div class="status" id="shape-name">Shape: Sphere</div>
        <div class="instruction">‚òùÔ∏è 1 Finger: Heart</div>
        <div class="instruction">‚úåÔ∏è 2 Fingers: Flower</div>
        <div class="instruction">ü§ü 3 Fingers: Saturn</div>
        <div class="instruction">üñêÔ∏è 5 Fingers: Sphere</div>
        <div class="instruction">üëå Pinch: Expand/Contract</div>
    </div>

    <!-- Hidden Video for Computer Vision -->
    <video id="video-element" playsinline></video>
    
    <!-- Three.js Canvas -->
    <div id="canvas-container"></div>

    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Import MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 15000;
        const PARTICLE_SIZE = 0.15;
        const MORPH_SPEED = 0.08;
        
        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        // Add subtle fog for depth
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const initialPositions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        
        // Initialize random positions
        for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
            initialPositions[i] = (Math.random() - 0.5) * 50;
            colors[i] = 1.0; // White initially
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(initialPositions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Create texture for particles (soft glow)
        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            map: sprite,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true,
            opacity: 0.8
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- SHAPE GENERATORS (Math) ---
        const shapes = {
            sphere: [],
            heart: [],
            flower: [],
            saturn: [],
            fireworks: []
        };

        function generateShapes() {
            // 1. SPHERE
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = 10;
                shapes.sphere.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }

            // 2. HEART
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Heart formula
                const t = Math.random() * Math.PI * 2;
                const r = Math.random(); // volume filler
                // x = 16sin^3(t)
                // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                // z = thickness
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 10; 
                
                // Scale down
                const s = 0.5;
                shapes.heart.push(x * s, y * s, z * s);
            }

            // 3. FLOWER (Rose/Sine)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const u = Math.random() * Math.PI * 2; // angle
                const v = Math.random() * Math.PI; // height
                const k = 4; // petals
                const r = 5 + 5 * Math.cos(k * u) * Math.sin(v);
                
                let x = r * Math.sin(v) * Math.cos(u);
                let y = r * Math.cos(v); // height
                let z = r * Math.sin(v) * Math.sin(u);

                shapes.flower.push(x, y, z);
            }

            // 4. SATURN (Sphere + Ring)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                if (i < PARTICLE_COUNT * 0.4) {
                    // Planet body
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const r = 6;
                    shapes.saturn.push(
                        r * Math.sin(phi) * Math.cos(theta),
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi)
                    );
                } else {
                    // Rings
                    const angle = Math.random() * Math.PI * 2;
                    const r = 10 + Math.random() * 8; // Ring radius 10 to 18
                    shapes.saturn.push(
                        r * Math.cos(angle),
                        (Math.random() - 0.5) * 0.5, // Flat ring
                        r * Math.sin(angle)
                    );
                }
            }

            // 5. FIREWORKS (Explosion vectors)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                // Highly variable radius
                const r = Math.random() * 25; 
                shapes.fireworks.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }
        }

        generateShapes();

        // --- STATE & INTERACTION ---
        let currentTarget = shapes.sphere;
        let expansionFactor = 1.0;
        let colorHue = 0;
        
        // --- MEDIAPIPE SETUP ---
        const videoElement = document.getElementById('video-element');
        const shapeNameUI = document.getElementById('shape-name');

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                
                // 1. ROTATION (Based on Palm Centroid)
                // Normalize roughly to -1 to 1 range
                const centerX = (hand[9].x - 0.5) * 2; 
                const centerY = (hand[9].y - 0.5) * 2;
                
                // Smoothly rotate particles container
                particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, centerX * 2, 0.1);
                particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, centerY * 2, 0.1);

                // 2. PINCH DETECTION (Thumb tip vs Index tip distance)
                const thumbTip = hand[4];
                const indexTip = hand[8];
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // Map distance: Close (0.05) -> 0.5 scale, Open (0.2+) -> 1.5 scale
                let targetScale = 1;
                if(distance < 0.05) targetScale = 0.2; // Collapsed
                else if(distance > 0.15) targetScale = 2.0; // Expanded
                else targetScale = 1.0;

                expansionFactor = THREE.MathUtils.lerp(expansionFactor, targetScale, 0.1);

                // 3. FINGER COUNTING (Simple Y-check against PIP joints)
                // Tips: 8, 12, 16, 20. PIPs: 6, 10, 14, 18
                let fingersUp = 0;
                if (hand[8].y < hand[6].y) fingersUp++;  // Index
                if (hand[12].y < hand[10].y) fingersUp++; // Middle
                if (hand[16].y < hand[14].y) fingersUp++; // Ring
                if (hand[20].y < hand[18].y) fingersUp++; // Pinky
                // Thumb is tricky, ignore for template switching to reduce noise

                switch(fingersUp) {
                    case 1: 
                        currentTarget = shapes.heart; 
                        shapeNameUI.innerText = "Shape: Heart";
                        colorHue = 0.0; // Red
                        break;
                    case 2: 
                        currentTarget = shapes.flower; 
                        shapeNameUI.innerText = "Shape: Flower";
                        colorHue = 0.8; // Pink/Purple
                        break;
                    case 3: 
                        currentTarget = shapes.saturn; 
                        shapeNameUI.innerText = "Shape: Saturn";
                        colorHue = 0.15; // Gold/Orange
                        break;
                    case 4:
                        currentTarget = shapes.fireworks; 
                        shapeNameUI.innerText = "Shape: Fireworks";
                        colorHue = Math.random(); // Random flash
                        break;
                    default: 
                        if(fingersUp > 3) {
                           currentTarget = shapes.sphere; 
                           shapeNameUI.innerText = "Shape: Sphere";
                           colorHue = 0.6; // Blue
                        }
                        break;
                }
            } else {
                // No hand detected - drift back to idle
                expansionFactor = THREE.MathUtils.lerp(expansionFactor, 1.0, 0.05);
                particles.rotation.y += 0.002; // Auto rotate
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        cameraUtils.start();

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.position.array;
            const colorAttribute = particles.geometry.attributes.color;

            // Animate Color
            const time = Date.now() * 0.001;
            const baseColor = new THREE.Color();
            baseColor.setHSL(colorHue, 1.0, 0.5);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const px = i * 3;
                const py = i * 3 + 1;
                const pz = i * 3 + 2;

                // Get Target Position based on shape
                let tx = currentTarget[px];
                let ty = currentTarget[py];
                let tz = currentTarget[pz];

                // Apply Expansion/Pinch Scale
                tx *= expansionFactor;
                ty *= expansionFactor;
                tz *= expansionFactor;

                // Add slight noise for "life"
                tx += Math.sin(time + i) * 0.05;
                ty += Math.cos(time + i) * 0.05;

                // Lerp current position to target
                positions[px] += (tx - positions[px]) * MORPH_SPEED;
                positions[py] += (ty - positions[py]) * MORPH_SPEED;
                positions[pz] += (tz - positions[pz]) * MORPH_SPEED;

                // Update Colors (gradient based on position + chosen hue)
                // Simple trick: mix chosen hue with position variation
                const pColor = new THREE.Color().setHSL(colorHue + (positions[py] * 0.02), 0.8, 0.6);
                
                colorAttribute.setXYZ(i, pColor.r, pColor.g, pColor.b);
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>